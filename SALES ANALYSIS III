ðŸŒŸð—£ð—¿ð—¼ð—¯ð—¹ð—²ð—º ð—¦ð˜ð—®ð˜ð—²ð—ºð—²ð—»ð˜:

Difficulty Level:Easy

â“ Problem link : https://leetcode.com/problems/sales-analysis-iii/description/?envType=problem-list-v2&envId=e97a9e5m

 

ðŸŒŸð—§ð—µð—² ð—–ð—µð—®ð—¹ð—¹ð—²ð—»ð—´ð—²:

The challenge is to report the products that were only sold in the first quarter of 2019. The key difficulty lies in ensuring that a product is not sold outside of this time period (before January 1, 2019, or after March 31, 2019) while including those that were sold exclusively within this time range.

ðŸŒŸð—œð—»ð—¶ð˜ð—¶ð—®ð—¹ ð—§ð—µð—¼ð˜‚ð—´ð—µð˜ð˜€:

When I first encountered the problem, my initial approach was to:

Identify all sales that happened within the first quarter of 2019.

Filter out the products that were sold outside of this range.

A JOIN between the Product and Sales tables seemed natural to access product details and sales data together. From there, using date comparisons within the WHERE clause or filtering within the HAVING clause felt like the next logical step.

 ðŸŒŸð—¢ð—½ð˜ð—¶ð—ºð—¶ð˜‡ð—®ð˜ð—¶ð—¼ð—» ð—¦ð˜ð—¿ð—®ð˜ð—²ð—´ð˜†:

The most efficient solution is likely using ð—¡ð—¢ð—§ ð—˜ð—«ð—œð—¦ð—§ð—¦, ð—²ð˜€ð—½ð—²ð—°ð—¶ð—®ð—¹ð—¹ð˜† ð—³ð—¼ð—¿ ð—¹ð—®ð—¿ð—´ð—² ð—±ð—®ð˜ð—®ð˜€ð—²ð˜ð˜€ ð˜„ð—¶ð˜ð—µ ð—®ð—½ð—½ð—¿ð—¼ð—½ð—¿ð—¶ð—®ð˜ð—² ð—¶ð—»ð—±ð—²ð˜…ð—¶ð—»ð—´.EXISTS and NOT EXISTS are optimized to stop scanning once a matching condition is found. This can be significantly faster than GROUP BY and aggregation, especially with large datasets.With proper indexing on product_id and sale_date, the database can quickly verify if sales exist both within and outside the target period, without needing to aggregate or sort records
1084

METHOD 1: GROUP BY AND HAVING WITH CONDITIONS

SELECT p.product_id, p.product_name
FROM Product p
JOIN Sales s ON p.product_id = s.product_id
GROUP BY p.product_id, p.product_name
HAVING MIN(s.sale_date) >= '2019-01-01'
   AND MAX(s.sale_date) <= '2019-03-31';


Explanation:
â€¢	JOIN between Product and Sales is used to link the product details.
â€¢	GROUP BY groups the sales by product_id and product_name.
â€¢	HAVING ensures that the minimum and maximum sale dates for each product are within the first quarter of 2019 (2019-01-01 to 2019-03-31).
â€¢	This approach leverages GROUP BY to aggregate the sales by product, then checks the minimum and maximum sale dates.
â€¢	Efficient in terms of filtering directly with MIN and MAX, which can use indexes on sale_date.
â€¢	If the Sales table is large, it will still need to scan all records for each product to compute the MIN and MAX, which may be costly.










1084

METHOD 2: SUBQUERIES

SELECT p.product_id, p.product_name
FROM Product p
WHERE p.product_id IN (
    SELECT DISTINCT s.product_id
    FROM Sales s
    WHERE s.sale_date BETWEEN '2019-01-01' AND '2019-03-31'
)
AND p.product_id NOT IN (
    SELECT DISTINCT s.product_id
    FROM Sales s
    WHERE s.sale_date < '2019-01-01' OR s.sale_date > '2019-03-31'
)

Explanation:
â€¢	The first subquery finds products sold in Q1 2019.
â€¢	The second subquery excludes any products that were sold outside of this period.
â€¢	The DISTINCT keyword ensures that we only consider unique product IDs.
â€¢	This solution uses subqueries to first find products sold in the first quarter of 2019, and then excludes those sold outside this time period.
â€¢	Separating the two conditions can make the logic clear and allows the database to optimize each subquery individually.
â€¢	Subqueries may lead to inefficiencies as each subquery could result in a full scan of the Sales table. This can be particularly slow if there are many rows, especially without proper indexing.
â€ƒ


1084

METHOD 3: NOT EXISTS

SELECT p.product_id, p.product_name
FROM Product p
WHERE EXISTS (
    SELECT 1 
    FROM Sales s 
    WHERE s.product_id = p.product_id 
    AND s.sale_date BETWEEN '2019-01-01' AND '2019-03-31'
)
AND NOT EXISTS (
    SELECT 1 
    FROM Sales s 
    WHERE s.product_id = p.product_id 
    AND (s.sale_date < '2019-01-01' OR s.sale_date > '2019-03-31')
);

Explanation:
â€¢	The first EXISTS checks if the product was sold in Q1 2019.
â€¢	The second NOT EXISTS ensures that the product was not sold outside of Q1 2019.
â€¢	EXISTS returns true if the subquery finds any matching rows, ensuring efficient checks.
â€¢	This approach uses EXISTS and NOT EXISTS to check the existence of sales in the first quarter and to ensure that there are no sales outside this period.
â€¢	This approach can be more efficient because it avoids grouping or aggregating large datasets. EXISTS works with indexed data and short-circuits once a matching record is found, potentially reducing the number of rows scanned.
â€¢	For smaller datasets, EXISTS might not be noticeably faster, but it scales well with larger data if proper indexes exist on product_id and sale_date.



1084

METHOD 4: HAVING SUM WITH CONDITIONS

SELECT
  Product.product_id,
  Product.product_name
FROM Product
INNER JOIN Sales
  USING (product_id)
GROUP BY 1, 2
HAVING SUM(
    Sales.sale_date < '2019-01-01'
    OR Sales.sale_date > '2019-03-31'
  ) = 0;
Explanation:
â€¢	INNER JOIN USING (product_id): This joins the Product and Sales tables using the product_id, ensuring that the sales data is combined with the corresponding product details.
â€¢	GROUP BY 1, 2: This groups the results by the first and second columns in the SELECT clause, which are Product.product_id and Product.product_name. Grouping is necessary to perform the aggregation and filtering for each product.
â€¢	The HAVING clause is used to filter out products based on the aggregated conditions.
â€¢	SUM(Sales.sale_date < '2019-01-01' OR Sales.sale_date > '2019-03-31'): This condition checks if any sale for the product occurred outside the first quarter of 2019.
â€¢	The SUM function adds up these TRUE values across all rows for a product.
â€¢	If a sale date is either before 2019-01-01 or after 2019-03-31, the expression evaluates to TRUE (which is treated as 1).
â€¢	HAVING ... = 0: This ensures that there were no sales for the product outside of the first quarter of 2019. If the sum is 0, it means that all sales for that product occurred between 2019-01-01 and 2019-03-31.
â€¢	This approach checks for sales outside of the first quarter using HAVING SUM, which counts any sales that occurred before or after the first quarter.
â€¢	The conditional SUM() effectively filters products and avoids additional subqueries or multiple checks. It's efficient when product_id and sale_date are indexed.



