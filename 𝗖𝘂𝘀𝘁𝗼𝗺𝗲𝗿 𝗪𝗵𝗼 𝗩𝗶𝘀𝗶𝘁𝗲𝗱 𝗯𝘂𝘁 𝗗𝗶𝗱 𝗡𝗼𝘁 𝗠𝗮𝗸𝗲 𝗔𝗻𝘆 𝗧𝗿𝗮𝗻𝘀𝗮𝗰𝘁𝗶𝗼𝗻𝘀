ğŸ¯ğ™‡ğ™€ğ™€ğ™ğ˜¾ğ™Šğ˜¿ğ™€ ğ™ğ™Œğ™‡ ğ˜¿ğ˜¼ğ™ğ˜¼ğ˜½ğ˜¼ğ™ğ™€ 45 ğ™Œğ™ğ™€ğ™ğ™ğ™„ğ™Šğ™‰ğ™ ğ˜¾ğ™ƒğ˜¼ğ™‡ğ™‡ğ™€ğ™‰ğ™‚ğ™€ 

Problem of the Day: ğŸš€ ğ—–ğ˜‚ğ˜€ğ˜ğ—¼ğ—ºğ—²ğ—¿ ğ—ªğ—µğ—¼ ğ—©ğ—¶ğ˜€ğ—¶ğ˜ğ—²ğ—± ğ—¯ğ˜‚ğ˜ ğ——ğ—¶ğ—± ğ—¡ğ—¼ğ˜ ğ— ğ—®ğ—¸ğ—² ğ—”ğ—»ğ˜† ğ—§ğ—¿ğ—®ğ—»ğ˜€ğ—®ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€

Today, I tackled an interesting problem on LeetCode: Customer Who Visited but Did Not Make Any Transactions.

Here's a brief overview of how I approached solving it.

 

ğŸŒŸğ—£ğ—¿ğ—¼ğ—¯ğ—¹ğ—²ğ—º ğ—¦ğ˜ğ—®ğ˜ğ—²ğ—ºğ—²ğ—»ğ˜:

Difficulty Level:Easy

â“ Problem link : https://leetcode.com/problems/customer-who-visited-but-did-not-make-any-transactions/description/?envType=problem-list-v2&envId=e97a9e5m

 

ğŸŒŸğ—§ğ—µğ—² ğ—–ğ—µğ—®ğ—¹ğ—¹ğ—²ğ—»ğ—´ğ—²:

The challenge here is to identify customers who visited the mall but did not make any transactions during those visits. The problem requires counting the number of such non-transactional visits for each customer. The key difficulty is efficiently excluding visits that resulted in transactions, while aggregating visits that didn't.

ğŸŒŸğ—œğ—»ğ—¶ğ˜ğ—¶ğ—®ğ—¹ ğ—§ğ—µğ—¼ğ˜‚ğ—´ğ—µğ˜ğ˜€:

When encountering the problem, the first thought is to join the Visits and Transactions tables using the visit_id column and identify which visits did not have any matching transaction records. A ğ—Ÿğ—˜ğ—™ğ—§ ğ—ğ—¢ğ—œğ—¡ comes to mind immediately, as it allows us to keep all visits, including those without matching transactions. ğ—¦ğ˜‚ğ—¯ğ—¾ğ˜‚ğ—²ğ—¿ğ˜† ğ˜„ğ—¶ğ˜ğ—µ ğ—¡ğ—¢ğ—§ ğ—œğ—¡: This can be less efficient with large datasets due to the NOT IN clause, which requires evaluating the entire subquery.ğ—¡ğ—¢ğ—§ ğ—˜ğ—«ğ—œğ—¦ğ—§ğ—¦: Similar in efficiency to LEFT JOIN, but in some cases, EXISTS can be optimized better for larger datasets by stopping the search once a match is found. ğ—–ğ—§ğ—˜: The CTE finds all visits where no transactions were made by doing a LEFT JOIN and filtering for NULL transactions.

 ğŸŒŸğ—¢ğ—½ğ˜ğ—¶ğ—ºğ—¶ğ˜‡ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¦ğ˜ğ—¿ğ—®ğ˜ğ—²ğ—´ğ˜†:

To optimize the solution, the use of a ğ—Ÿğ—˜ğ—™ğ—§ ğ—ğ—¢ğ—œğ—¡ can minimize the rows that need to be scanned.By filtering with NULL values directly in the LEFT JOIN result, we avoid costly subqueries and make use of indexed columns like visit_id.This ğ—®ğ—½ğ—½ğ—¿ğ—¼ğ—®ğ—°ğ—µ ğ—¶ğ˜€ ğ—²ğ—³ğ—³ğ—¶ğ—°ğ—¶ğ—²ğ—»ğ˜ ğ—¯ğ—²ğ—°ğ—®ğ˜‚ğ˜€ğ—² ğ—¶ğ˜ ğ—¹ğ—²ğ˜ƒğ—²ğ—¿ğ—®ğ—´ğ—²ğ˜€ ğ˜ğ—µğ—² ğ˜€ğ˜ğ—¿ğ˜‚ğ—°ğ˜ğ˜‚ğ—¿ğ—² ğ—¼ğ—³ ğ˜ğ—µğ—² ğ—±ğ—®ğ˜ğ—® ğ˜„ğ—¶ğ˜ğ—µ ğ—ºğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—¿ğ—²ğ—±ğ˜‚ğ—»ğ—±ğ—®ğ—»ğ—°ğ˜† ğ—®ğ—»ğ—± ğ˜„ğ—¼ğ—¿ğ—¸ğ˜€ ğ˜„ğ—²ğ—¹ğ—¹ ğ—¼ğ—» ğ—¹ğ—®ğ—¿ğ—´ğ—² ğ—±ğ—®ğ˜ğ—®ğ˜€ğ—²ğ˜ğ˜€ ğ˜„ğ—¶ğ˜ğ—µ ğ—®ğ—½ğ—½ğ—¿ğ—¼ğ—½ğ—¿ğ—¶ğ—®ğ˜ğ—² ğ—¶ğ—»ğ—±ğ—²ğ˜…ğ—¶ğ—»ğ—´.

Alternatively, NOT EXISTS can be used if we want to avoid bringing in unnecessary columns from the Transactions table, which can improve performance for large datasets.Ensure that visit_id is indexed in both Visits and Transactions tables for faster lookup and join operations.



Looking forward to sharing more soon!ğŸ’›

ğŸ‘‰ Feel free to explore my Leetcode here:https://lnkd.in/e4JAGU97

 ğŸ“Œ Leetcode SQL Database 45 ques challenge:https://lnkd.in/eBAN_Psk


â€ƒ


1581

METHOD 1: LEFT JOIN AND GROUP BY

SELECT
  Visits.customer_id,
  COUNT(Visits.visit_id) AS count_no_trans
FROM Visits
LEFT JOIN Transactions
  USING (visit_id)
WHERE Transactions.transaction_id IS NULL
GROUP BY 1;


Explanation:
â€¢	LEFT JOIN: We join the Visits table with the Transactions table on visit_id, and since it's a LEFT JOIN, all records from Visits will be kept, even if there is no matching record in Transactions.
â€¢	WHERE t.transaction_id IS NULL: This condition ensures that only visits without transactions are counted.
â€¢	COUNT(v.visit_id): We count how many visits without transactions each customer made.
â€¢	GROUP BY v.customer_id: Groups the results by the customer_id to get the total count of non-transaction visits per customer.
â€¢	Ensures we keep all visits from the Visits table and only bring in matching rows from Transactions. Any visit without a transaction will have a NULL in the transaction_id field.
â€¢	This approach is efficient because it leverages the structure of the data with minimal redundancy and works well on large datasets with appropriate indexing.








1581

METHOD 2: SUBQUERY WITH NOT IN


SELECT 
    v.customer_id, 
    COUNT(v.visit_id) AS count_no_trans
FROM Visits v
WHERE v.visit_id NOT IN (
    SELECT t.visit_id 
    FROM Transactions t
)
GROUP BY v.customer_id;


Explanation:
â€¢	NOT IN: This subquery retrieves all visit_ids from the Transactions table, and the main query returns only visits that are not present in that list (i.e., visits without transactions).
â€¢	COUNT(v.visit_id): Again, we count the number of visits without transactions.
â€¢	GROUP BY v.customer_id: Groups the results by customer_id to get the number of non-transaction visits for each customer.â€ƒ


1581

METHOD 3: NOT EXISTS

SELECT 
    v.customer_id, 
    COUNT(v.visit_id) AS count_no_trans
FROM Visits v
WHERE NOT EXISTS (
    SELECT 1 
    FROM Transactions t 
    WHERE t.visit_id = v.visit_id
)
GROUP BY v.customer_id;


Explanation:
â€¢	NOT EXISTS: For each visit_id in the Visits table, this checks if there is no corresponding entry in the Transactions table. If no matching entry exists, the visit is considered as having no transaction.
â€¢	COUNT(v.visit_id): Counts the visits with no transactions.
â€¢	GROUP BY v.customer_id: Groups the results by customer_id to calculate the total number of non-transaction visits per customer.











1581

METHOD 4: COMMON TABLE EXPRESSION (CTE)


WITH NoTransactions AS (
    SELECT v.visit_id, v.customer_id
    FROM Visits v
    LEFT JOIN Transactions t
        ON v.visit_id = t.visit_id
    WHERE t.transaction_id IS NULL
)
SELECT 
    nt.customer_id, 
    COUNT(nt.visit_id) AS count_no_trans
FROM NoTransactions nt
GROUP BY nt.customer_id;


Explanation:
â€¢	CTE NoTransactions: The CTE finds all visits where no transactions were made by doing a LEFT JOIN and filtering for NULL transactions.
â€¢	Main Query: The main query simply counts the non-transaction visits from the CTE.
â€¢	COUNT(nt.visit_id): Counts the number of non-transaction visits for each customer.
â€¢	GROUP BY nt.customer_id: Groups the results by customer_id to aggregate the visits without transactions.


